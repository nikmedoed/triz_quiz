<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>{{ step.title if step else 'ТРИЗ КВИЗ' }}</title>
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;900&display=swap" rel="stylesheet" />
  <link rel="stylesheet" href="/static/styles.css" />
  <script src="/static/app.js" defer></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<body>
  <header class="topbar">
    <div class="top-left">
      <div class="brand">{{ stage_title }}</div>
    </div>
    <div class="top-center">
      {% if timer_id %}
      <div class="timer" id="{{ timer_id }}">{{ timer_text }}</div>
      {% endif %}
    </div>
    <div class="top-right">
      {% if show_next is not defined or show_next %}
      <button class="btn btn-primary" onclick="post('/api/next')">Далее</button>
      {% endif %}
    </div>
  </header>
  <main class="main">
    <div class="content{% if content_class %} {{ content_class }}{% endif %}">
      {% block content %}{% endblock %}
    </div>
  </main>
  <footer class="bottombar">
    <div class="footer-center">
      {{ instruction }}
    </div>
    <div class="footer-right">
      {% if status_mode == 'answers' %}
      <div class="status" id="answersStatus" data-total="{{ status_total }}">
        <div>Ответы: <span id="answersCount">{{ status_current }}</span> / {{ status_total }}</div>
        <div>Последний: <span id="lastAnswerAgo">{{ status_last }}</span></div>
      </div>
      {% elif status_mode == 'votes' %}
      <div class="status">
        <div>Проголосовало: <span id="votesCount">{{ status_current }}</span> / {{ status_total }}</div>
        <div>Последний: <span id="lastVoteAgo">{{ status_last }}</span></div>
      </div>
      {% endif %}
      {% if show_reset %}
      <form method="get" action="/reset" class="reset-form">
        <button class="btn btn-secondary" type="submit">Сброс БД</button>
      </form>
      {% endif %}
    </div>
  </footer>
  <script>
    async function post(url){
      await fetch(url, {method:'POST'});
    }
    function formatAgo(sec){
      if(sec==null || sec==='-' || sec==='') return '-';
      sec = parseInt(sec);
      if(isNaN(sec)) return '-';
      if(sec >= 60){ const m=Math.floor(sec/60); const s=sec%60; return m+' мин '+s+' с'; }
      return sec+' с';
    }
    const timerEl = document.getElementById('ideaTimer')
    || document.getElementById('voteTimer')
    || document.getElementById('quizTimer');
  const sinceVal = '{{ since.isoformat() if since is defined else "" }}';
  if (timerEl && sinceVal){
    const start = new Date(sinceVal + 'Z').getTime();
    const durations = { ideaTimer: 5*60*1000, voteTimer: 60*1000, quizTimer: 60*1000 };
    function tick(){
      let left = durations[timerEl.id] - (Date.now() - start);
      if(left < 0) left = 0;
      const m = String(Math.floor(left/60000)).padStart(2,'0');
      const s = String(Math.floor((left%60000)/1000)).padStart(2,'0');
      timerEl.textContent = m+':'+s;
    }
    setInterval(tick,1000); tick();
  }
    const lastAnswerEl = document.getElementById('lastAnswerAgo');
    const lastVoteEl = document.getElementById('lastVoteAgo');
    let lastAnswerSec = lastAnswerEl ? parseInt(lastAnswerEl.textContent) : null;
    let lastVoteSec = lastVoteEl ? parseInt(lastVoteEl.textContent) : null;
    if (isNaN(lastAnswerSec)) lastAnswerSec = null;
    if (isNaN(lastVoteSec)) lastVoteSec = null;
    if (lastAnswerEl) lastAnswerEl.textContent = formatAgo(lastAnswerSec);
    if (lastVoteEl) lastVoteEl.textContent = formatAgo(lastVoteSec);

    const answersStatusEl = document.getElementById('answersStatus');
    const answersCountEl = document.getElementById('answersCount');
    const totalAnswers = answersStatusEl ? parseInt(answersStatusEl.dataset.total) : null;
    function updateAnswersStatus(){
      if (answersStatusEl && answersCountEl && totalAnswers !== null){
        const current = parseInt(answersCountEl.textContent);
        if (!isNaN(current) && current >= totalAnswers){
          answersStatusEl.classList.add('complete');
        } else {
          answersStatusEl.classList.remove('complete');
        }
      }
    }
    updateAnswersStatus();
    setInterval(() => {
      if (lastAnswerSec !== null){ lastAnswerSec++; lastAnswerEl.textContent = formatAgo(lastAnswerSec); }
      if (lastVoteSec !== null){ lastVoteSec++; lastVoteEl.textContent = formatAgo(lastVoteSec); }
    }, 1000);
    const ws = new WebSocket((location.protocol === 'https:' ? 'wss://' : 'ws://') + location.host + '/ws');
    ws.onmessage = (ev) => {
      const msg = JSON.parse(ev.data);
      if (msg.type === 'reload') location.href = '/';
      if (msg.type === 'idea_progress'){
        const cnt = document.getElementById('answersCount');
        if (cnt) { cnt.textContent = msg.count; updateAnswersStatus(); }
        if (lastAnswerEl && msg.last !== undefined){ lastAnswerSec = msg.last; lastAnswerEl.textContent = formatAgo(lastAnswerSec); }
      }
      if (msg.type === 'mcq_progress'){
        const cnt = document.getElementById('answersCount');
        if (cnt) { cnt.textContent = msg.count; updateAnswersStatus(); }
        if (lastAnswerEl && msg.last !== undefined){ lastAnswerSec = msg.last; lastAnswerEl.textContent = formatAgo(lastAnswerSec); }
      }
      if (msg.type === 'vote_progress'){
        const vcnt = document.getElementById('votesCount');
        if (vcnt) vcnt.textContent = msg.count;
        if (lastVoteEl && msg.last !== undefined){ lastVoteSec = msg.last; lastVoteEl.textContent = formatAgo(lastVoteSec); }
      }
    };
  </script>
</body>
</html>
